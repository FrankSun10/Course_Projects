
//
// STRINGTABLE.JAVA
// A hash table mapping Strings to their positions in the the pattern sequence
// You get to fill in the methods for this part.
//
public class StringTable {

	//    
	// Create an empty table big enough to hold maxSize records.
	//
	public int size;
	public int possibleSize;
	public Record[]  patternRecord;
	public int numelements;
	public double loadFactor;

	public StringTable(int maxSize) 
	{
		this.possibleSize = maxSize;
		int power = 0;
		for(int i = 0; Math.pow(2, i) < this.possibleSize; i++){
			power = i;
		}
		this.size = (int)Math.pow(2,power);
		this.patternRecord = new Record[this.size];
		for(int i = 0; i < this.size; i++){
			this.patternRecord[i] = null;
		}
		this.numelements = 0;
		this.loadFactor = 0;

	}

	/**
	 * Insert a Record r into the table.  Return true if
	 *  successful, false if the table is full.  You shouldn't ever
	 *  get two insertions with the same key value, but you may
	 *  simply return false if this happens.
	 * @param r
	 * @return
	 */
	public boolean insert(Record r) 
	{ 
		int finalHashed = finalHash(r.getKey());
		int toHashKey = toHashKey(r.getKey());
		if(find(r.getKey()) == null || find(r.getKey()).getKey().equals("Deleted")){
			patternRecord[finalHashed] = r;
			patternRecord[finalHashed].setHashKey(toHashKey);
			this.numelements += 1;
			this.loadFactor = (double)this.numelements / this.size;
			if(this.loadFactor >= 0.25){
				doubleSize();
			}
			return true;
		}
		else return false;

	}

	/**
	 * Delete a Record r from the table.  Note that you'll have to
	 * find the record first unless you keep some extra information
	 * in the Record structure.
	 * @param r
	 */
	public void remove(Record r) 
	{
		if(find(r.getKey()) != null){

			int h = finalHash(r.getKey());
			patternRecord[h] = new Record("Deleted");
			this.numelements = this.numelements - 1;
		}
	}

	/**
	 * Find a record with a key matching the input.  Return the
	 * record if it exists, or null if no matching record is found.
	 * @param key
	 * @return
	 */
	public Record find(String key) 
	{
		int v = toHashKey(key);
		int h1 = baseHash(v);
		int h2 = stepHash(v);
		int h = h1;
		// first check the base hash
		if(patternRecord[h1] == null){
			return null;
		}
		if(patternRecord[h1].getKey().equals(key)){
			return patternRecord[h1];
		}
		// then check the step hash
		for(int i = 0; i < this.size; i++){
			h = (h + h2) % this.size;
			if(patternRecord[h] == null){
				return null;
			}
			// this is the first section in Part two. Use the toHashKey value to speed 
			// up the finding process, so as to speed the maching process
			if(patternRecord[h].getHashKey() == v){         
				if(patternRecord[h].getKey().equals(key)){  
					return patternRecord[h];                
				}
			}
		}
		return null; 
	}

	///////////////////////////////////////////////////////////////////////

	// Convert a String key into an integer that serves as input to hash
	// functions.  This mapping is based on the idea of a linear-congruential
	// pesudorandom number generator, in which successive values r_i are 
	// generated by computing
	//    r_i = ( A * r_(i-1) + B ) mod M
	// A is a large prime number, while B is a small increment thrown in
	// so that we don't just compute successive powers of A mod M.
	//
	// We modify the above generator by perturbing each r_i, adding in
	// the ith character of the string and its offset, to alter the
	// pseudorandom sequence.
	//
	int toHashKey(String s)
	{
		int A = 1952786893;
		int B = 367257;
		int v = B;

		for (int j = 0; j < s.length(); j++)
		{
			char c = s.charAt(j);
			v = A * (v + (int) c + j) + B;
		}

		if (v < 0) v = -v;
		return v;
	}

	// next build the first hash function
	int baseHash(int hashKey){
		double a1 = (Math.sqrt(5)-1.0) / 2.0;
		int h1 = (int)(this.size * (hashKey * a1 - (int)(hashKey * a1))); 
		return h1;
	}

	// next build the second hash function
	int stepHash(int hashKey){
		double a2 =  Math.E / 4; // Thanks to Alan
		int h2 = (int)(this.size * (hashKey * a2 - (int)(hashKey * a2)));
		if(h2 % 2 == 0) {
			return h2 +1;
		}
		else return h2;
	}

	/**
	 * build the combined final hash function
	 * @param s
	 * @return
	 */
	int finalHash(String s){
		int k = toHashKey(s);
		int h1 = baseHash(k);
		int h2 = stepHash(k);
		int h = h1;
		// check the base hash
		if(patternRecord[h1] == null || patternRecord[h1].getKey() == s){
			return h = h1;
		}
		// check with step hash 
		for(int i = 0 ; i < this.size; i++){
			h = ( h + h2) % this.size;
			if(patternRecord[h] == null || patternRecord[h].getKey() == s){
				return h;
			}
		}
		return -1;
	}
	
	/**
	 * build a method to double size the current table
	 */

	public void doubleSize(){
		int currentSize = this.size;
		Record[] doublesized = new Record[2*currentSize];
		// build a new Record array which is the same as the current table
		// use this new Record array to rehash. In this way, I think I can 
		// avoid building another new StringTable and ignore the maxSize
		Record[] broker = new Record[currentSize];
		for(int i = 0; i < currentSize; i++){
			broker[i] = this.patternRecord[i];
		}
		this.size = 2 * currentSize;
		this.patternRecord = doublesized;
		// rehash the elements in the original table to the double-sized one
		for(int i = 0; i < currentSize; i++){
			if(broker[i] != null){
				int finalHashed = finalHash(broker[i].getKey());
				if(finalHashed != -1 ){                       
					patternRecord[finalHashed] = broker[i];
				}
			}
		}
	}

}
